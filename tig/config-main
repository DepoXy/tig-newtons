# vim:tw=0:ts=2:sw=2:et:norl:ft=conf
# Author: Landon Bouma (landonb &#x40; retrosoft &#x2E; com)
# Project: https://github.com/depoxy/tig-newtons#ğŸ
# License: MIT. Please find more in the LICENSE file.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# SYNC_ME:
#
#   cd path/to/tig-newtons
#   meld tig/config-diff tig/config-main &
#
# Only difference should be 'bind main...' vs. 'bind diff', so commands
# don't apply to other views (pager, reflog, refs, stage, stash, status),
# because tig config doesn't support reusing code for multiple commands
# (alternating, we could immediately shell-out, but I'd rather not).
#
# In many case, using 'generic' is fine, if the binding doesn't shadow
# other view bindings. But there are a few symbols defined only for the
# special views, e.g., the ! binding is defined separately for multiple
# views (reflogs, refs, stage, status).

# YOU: Per DepoXy convention (htt

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# SAVVY: If this returns nonzero, tig prints "Press Enter to continue".
# - Otherwise we could prompt ourselves and return 0, but let's tig it.
bind main ! >sh -c " \
  git_upraise_revision______________________ () { \
    echo; \
    local tnewtons=\"${TIGNEWTONSPATH:-${TIGNEWTONSPATH:-${HOME}/.kit/git}/tig-newtons}\"; \
    if [ ! -d \"${tnewtons}\" ]; then \
      >&2 echo \"ERROR: To use this feature, please install tig-newtons to:\"; \
      >&2 echo \"  ${tnewtons}\"; \
      >&2 echo \"Or use the TIGNEWTONSPATH environ.\"; \
      >&2 echo; \
      return 1; \
    fi; \
    local wipped=false; \
    git add -A \
      && git commit -q --no-verify -m 'PRIVATE: WIP [tig !]' \
      && wipped=true; \
    local bubble_cmd=\"${tnewtons}/bin/git-rebase-bubble-commit\"; \
    echo \"git rebase -i %(commit)^\"; \
    local exit_val; \
    ${bubble_cmd} \"%(commit)^\" ${wipped}; \
    exit_val=$?; \
    ${wipped} && git reset --mixed @~1; \
    echo; \
    return ${exit_val}; \
  }; git_upraise_revision______________________"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# The following commands work on a range on commits.
# - The mechanism works across two commands:
#   - The user first selects a starting commit.
#   - Then the user selects an ending commit and is prompted to
#     choose the action:
#     - Cherry-pick range, but insist commits not in HEAD history
#       (i.e., only works if user runs `tig <some-other-branch>`,
#        use case being user wants to cherry-pick commits from a
#        separate branch (DUNNO: Is there a use case for picking
#        commits from the same branch?));
#     - Move first rev. before or after second rev.; or
#     - Squash or Fixup first rev. into second rev.
#   - Note we could instead create multiple bindings, one for each
#     action, but that's at least 5 commands and we don't have many
#     available keyboard bindings remaining from which to pick.
# - Perhaps one day we'll PR tig to highlight the first commit selected,
#   but for now we'll use a temporary tag to mark the first selection.
#   - There are emoji racing flags, but not the green starting flag.
#     - So what's a good, catchy symbol to use?
#     - Note that tig doesn't show all emoji characters, or at least
#       that's my experience on Linux Mint 19.3 (which is weird,
#       because I see these same symbols fine in gVim and bash).
#     - Looking at the green emojis and flags:
#         git tag -f "ğŸš©ğŸğŸª´ğŸŒ±ğŸ²ğŸ‰ğŸ¦•ğŸ¦šğŸ’šğŸ«‘ğŸ¥’ğŸ¥¦ğŸ”‹ğŸ“—ğŸ’µğŸ’¹ğŸ§ªâ™âœ…âœ³ï¸-â‡ï¸-ğŸˆ¯ğŸŸ¢-ğŸŸ©ğŸğŸŒğŸ´ğŸ³-ğŸ³ï¸"
#                     ^^^^  ^^^^^^^^  ^^  ^^^^^^^^^^^^  ^^^^^^^^^^     ^^^^^^^^^^^
#       The ^^-underscored emoji appear in tig,
#       and any emoji followed by a dash appears only uses a single
#       character width in tig though the emoji is 2 em, so it bleeds.
#     - Though maybe the "red flag" emoji isn't the worst, it does
#       draw the eye better than green, methinks.
# - I originally thought user could '@' once to mark first commit, then
#   '@' again to mark second commit. But if we want to use tig's %(prompt),
#   which tig resolves before running the shell command, we should use a
#   separate final-commit binding, so the user is not %(prompt)ed on the
#   first-commit binding.
#   - Some bindings I considered:
#     - Use '@' for first, and <C-@> (with inherent <C-Space> alias) for final.
#     - Use '(' for first, and ')' for final.
#     - Or use '[' and ']', and save user two Shift presses.
# - Note using `+sh` vs. `>sh`:
#   - The 'main' view updates immediately on `bind main [ >sh ...`,
#     but it doesn't update on `bind main [ +sh ...`. But it's
#     the latter that lets us echo to the status line. Phooey.
#   - I tested each refresh-mode, including periodic, and only
#     `refresh-mode = after-command` with `>sh` causes refresh.
#   - It'd be nice to print a status message, e.g.,
#       echo \"Now select a later commit and press ']'...\";
#     but, oh well, nothing we can't solve in post!:
#     - MAYBE/2023-02-13: Another tig PR idea: Refresh view on '+sh';
#       or maybe it's that 'periodic' or 'auto' only check if commit
#       history changed, but don't monitor tags.

bind main [ >sh -c " \
  revision_range_cmd__select_first_commit___ () { \
    local tnewtons=\"${TIGNEWTONSPATH:-${TIGNEWTONSPATH:-${HOME}/.kit/git}/tig-newtons}\"; \
    if [ ! -d \"${tnewtons}\" ]; then \
      >&2 echo \"ERROR: To use this feature, please install tig-newtons to:\"; \
      >&2 echo \"  ${tnewtons}\"; \
      >&2 echo \"Or use the TIGNEWTONSPATH environ.\"; \
      >&2 echo; \
      return 1; \
    fi; \
    local tag_prefix='ğŸš©-START-HERE-ğŸš©'; \
    local starting_tag=\"${tag_prefix}--ğŸ-PPID-${PPID}-ğŸ\"; \
    git tag | grep \"^${tag_prefix}.*\" | xargs -n 1 -I % git tag -d % > /dev/null; \
    git tag -f \"${starting_tag}\" \"%(commit)\"; \
  }; revision_range_cmd__select_first_commit___"

# I'm torn on using %(prompt) or shelling-out and prompting user.
# - The %(prompt) resolves before the shell code runs, so there's a chance
#   user didn't set the beginning tag, and we'll prompt and then fail.
# - On the other hand, if we don't %(prompt), we can fail if not starting
#   tag, but then we'll have to prompt user through the shell, which is
#   not as elegant and using the status line.
# - We'll keep it in-house for now and see how it goes; user's will
#   probably quickly learn to set the starting tag first, and also
#   this way new users will more easily discover what this binding
#   does.
#   - Oh, another benefit to the shell-out prompt is `read -n 1`,
#     saving user a carriage return.
bind main ] >sh -c " \
  revision_range_cmd__select_final_commit___ () { \
    local action=\"%(prompt Choose action: [p]ick, [b]efore, [a]fter, [s]quash, or [f]ixup ? )\"; \
    local tag_prefix='ğŸš©-START-HERE-ğŸš©'; \
    local starting_tag=\"${tag_prefix}--ğŸ-PPID-${PPID}-ğŸ\"; \
    local second_commit; \
    second_commit=\"$(git rev-parse \"refs/tags/${starting_tag}\" 2> /dev/null)\"; \
    if [ $? -ne 0 ]; then \
      git tag | grep \"^${tag_prefix}.*\" | xargs -n 1 -I % git tag -d % > /dev/null; \
      >&2 echo \"ERROR: Please set the starting commit first to use this feature\"; \
      >&2 echo \"- Select the starting commit and press '['\"; \
      >&2 echo \"- Next select another commit and press ']'\"; \
      >&2 echo \"- Bonus: To \\\"cancel\\\", press '{'\"; \
      >&2 echo; \
      return 1; \
    fi; \
    echo; \
    local wipped=false; \
    git add -A \
      && git commit -q --no-verify -m 'PRIVATE: WIP <tig ]>' \
      && wipped=true; \
    local tnewtons=\"${TIGNEWTONSPATH:-${TIGNEWTONSPATH:-${HOME}/.kit/git}/tig-newtons}\"; \
    local range_cmd=\"${tnewtons}/bin/two-part-tig-command-rebaser\"; \
    local exit_val; \
    ${range_cmd} \"${action}\" \"${second_commit}\" \"%(commit)\"; \
    exit_val=$?; \
    if [ ${exit_val} -eq 0 ]; then \
      git tag | grep \"^${tag_prefix}.*\" | xargs -n 1 -I % git tag -d % > /dev/null; \
    fi; \
    ${wipped} && git reset --mixed @~1; \
    echo; \
    return ${exit_val}; \
  }; revision_range_cmd__select_final_commit___"

# Might as well have a way to decide not to complete the mission...
# though not sure Shift-[ is the best binding. But maybe it is?
bind main { >sh -c " \
  revision_range_cmd__select_first_commit___ () { \
    local tag_prefix='ğŸš©-START-HERE-ğŸš©'; \
    git tag | grep \"^${tag_prefix}.*\" | xargs -n 1 -I % git tag -d % > /dev/null; \
  }; revision_range_cmd__select_first_commit___"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

