#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Author: Landon Bouma <https://tallybark.com/>
# Project: https://github.com/DepoXy/tig-newtons#üçé
# License: MIT. Please find more in the LICENSE file.

# USAGE:
#
#   GIT_SEQUENCE_EDITOR='/path/to/git-rebase-bubble-up' \
#     git -c rebase.instructionFormat=%H \
#       rebase -i "<revision-before-bubble-target>"
#
# USETO:
#
#   Rebase so the first commit or range of commits become the latest
#   commit(s) (where the last commit in the range is the new HEAD),
#   or os that the first commit or range of commits is placed after
#   another commit ahead of it (which is specified by a special
#   Git tag).
#
#   - This is a contactless rebase, fully automated using awk.
#
#   - The special tag feature only works when called via tig config
#     shell command (specifically tig-newton's). If called otherwise,
#     the editor will only move the oldest commit to be latest commit.
#
# REFER:
#
#   The `awk -i inplace` specifies an awk extension:
#
#     https://www.gnu.org/software/gawk/manual/html_node/Extension-Sample-Inplace.html

# DEV: Uncomment to show rebase-todo before and after:
#  DX_SHOW_TODO=true
DX_SHOW_TODO=${DX_SHOW_TODO:-false}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# Git passes todo path, e.g., /proj/.git/rebase-merge/git-rebase-todo
range_seditor_bubble_up () {
  local rebase_todo_path="$1"

  # Git-rebase prints a line without a newline:
  #   hint: Waiting for your editor to close the file...
  # So do that now.
  echo

  # Load `range_command_print_target_match`, `print_todo_maybe`.
  local tnewtons_bin="$(dirname -- "$0")"
  . "${tnewtons_bin}/range-command-common.sh"

  print_todo_maybe "${rebase_todo_path}" "before"

  local rebase_cmd="$(range_command_print_command)"
  local target_match="$(range_command_print_target_match)"
  # The until_match is unset if only one commit being moved, else
  # it represents the end of the selected commit range.
  local until_match="$(range_command_print_until_match)"

  # DEV: This'd be your error.
  if [ -z "${rebase_cmd}" ]; then
    >&2 echo "ERROR: DEV: Missing rebase_cmd"

    exit 1
  fi

  ${DX_SHOW_TODO} && >&2 echo -e \
    "rebase_cmd   : ${rebase_cmd}" \
    "\nuntil_match  : ${until_match}" \
    "\ntarget_match : ${target_match}"

  local rewrite_message=""
  local rebase_relative=""
  if [ "${rebase_cmd}" = "fixup" ]; then
    # The user selected range before target to "fixup" into target, so
    # conceptually they probably except the target commit message to be
    # used as the final commit message. Because the implementation
    # technically squashes the target and most of the range into the
    # first range commit, we need to fix the commit message in post.
    # (An alternative would be to move the range *after* the target and
    #  use 'fixup' on all the range commits, but then we might create
    #  unnecessary conflicts.)
    rewrite_message="exec git commit --amend --message \\\"\$( \
      git log -1 --format=%B $(range_command_print_target_rev) \
    )\\\""
  elif [ "${rebase_cmd}" = "fixup2" ]; then
    # Use most recent range commit's message.
    rewrite_message="exec git commit --amend --message \\\"\$( \
      git log -1 --format=%B $(range_command_print_chosen_or_until_rev) \
    )\\\""

    rebase_cmd="fixup"
  elif [ "${rebase_cmd}" = "before" ] || [ "${rebase_cmd}" = "after" ]; then
    rebase_relative="${rebase_cmd}"

    rebase_cmd="pick"
  fi

  # Use arrays and state to print first commit, or a range of commits,
  # after target rev.
  # - Also discard comment lines, so final print_todo_maybe is less noisy.
  awk -i inplace "
    BEGIN { state = 0; i_range = 0; target_pick = \"\"; }

    function print_range_commits_and_target() {
      if (\"${rebase_relative}\" == \"after\") {
        print target_pick;
      }
      for (i_todo = 0; i_todo < i_range; i_todo++) {
        if ((i_todo != 0) || (\"${rebase_relative}\" == \"after\")) {
          sub(/^pick /, \"${rebase_cmd} \", range_commits[i_todo]);
        }
        print range_commits[i_todo];
      }
      if (\"${rebase_relative}\" != \"after\") {
        sub(/^pick /, \"${rebase_cmd} \", target_pick);
        print target_pick;
      }
      if ((i_range > 0) && (\"${rewrite_message}\" !~ /^\$/)) {
        # action: 'f' fixup, 'F' fixup2
        print \"${rewrite_message}\";
      }
    }

    state == 0 {
      if ((\"${until_match}\" == \"//\") || (\$0 ~ ${until_match})) {
        if (\"${until_match}\" == \"${target_match}\") {
          target_pick = \$0;
          state = 2;
        } else {
          range_commits[i_range] = \$0;
          i_range++;
          state = 1;
        }
      } else {
        range_commits[i_range] = \$0;
        i_range++;
      }
      next;
    }

    \$0 ~ ${target_match} && state == 1 {
      target_pick = \$0;
      state = 2;
      next;
    }
    \$0 ~ /^\$/ && state == 1 {
      state = 2;
      next;
    }

    state == 2 {
      print_range_commits_and_target();
      state = 3;
    }

    \$0 ~ /^\$/ { next; }
    \$0 ~ /^#/ { next; }
    1" ${rebase_todo_path}

  print_todo_maybe "${rebase_todo_path}" "after"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

PROG_NAME="range-seditor-bubble-up"

main () {
  range_seditor_bubble_up "$@"
}

# Complain if sourced (from any shell), or not run via Bash.
if [ -z "${BASH_SOURCE}" ] || [ "$0" != "${BASH_SOURCE[0]}" ]; then
  >&2 echo "ERROR: Run this script with Bash [${PROG_NAME}]"

  false
else
  main "$@"
fi

